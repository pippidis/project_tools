# USER MANUAL
This document serves as a guide to understand and work with the setup of this project. 
Quite a lot of this is written by chatGPT, but modified by me. 

## Project Structure
Each module in our system follows a consistent structure:

### Root

The root directory of the system contains several directories and files that facilitate the operation and organization of the application:

- `assets/`: Stores static resources used across the system.
- `logs/`: Collects application-generated log files for monitoring and debugging.
- `module_1/`, `module_2/`, `module_3/`: Independent modules, each encapsulating specific functionality and associated tests.
- `temp/`: Used for temporary file storage during application execution.
- `.pytest_cache/`: Generated by pytest, it holds data to optimize test runs.
- `.gitignore`: Lists files and directories that Git should ignore.
- `main.py`: Acts as the primary entry point to initiate the system's various operational modes.
- `readme.md`: Provides documentation for system setup and usage guidelines.

The `main.py` script in the root is pivotal, orchestrating the integration of functionalities from the modules into cohesive use cases such as initializing the GUI or server. This arrangement ensures that individual components remain decoupled, promoting maintainability and scalability. The `readme.md` is an essential guide for understanding the system's architecture and how to interact with it.

### Modules
Contains all the source code and tests related to that module.
  - `code/`: Contains the source code for the module.
    - `utils.py`: Example utility file; but assumed to be nessesary for each component
  - `tests/`: Contains all tests for the module.
    - `conftest.py`: Contains fixture definitions used across multiple test files.
    - `test_*.py`: Test files containing the test cases.

Modules are designed to be as decoupled as possible to ensure that changes in one module minimally affect others. This separation also facilitates easier testing and maintenance.

### Importing Functionality from Other Modules
When writing a GUI module or any module that requires functionality from another:
- Import necessary functions directly if they are in the same module.
- For functionality from a separate module, use absolute imports referencing the project's structure.
- Example:
  ```python
  # Absolute import from another module within the project
  from some_other_module.code.gui_utils import some_gui_function
  ```

- Ensure you have a clear understanding of the project's structure and the relationships between modules.

Be very carefullwhen dooing this. The system is set up so that it should easily be decupled and seperated into different repos at a later points. 


## Testing
This system has pytest set up for the entire system. Everything should be tested within reason. 

### How to Run Tests

- **For the Whole System**: Navigate to the root directory of the project and run:
  ```
  pytest


  --
  python C:\python311\lib\site-packages\pytest\__main__.py
  ```
  This will discover and run all tests in all modules.

- **For Just One Module**: Navigate to the module's directory and run:
  ```
  pytest tests/
  ```
  This will run all tests in the specified module's `tests` directory.

### Writing a Direct Test

- **Without Creating a Fixture**:
  - Create a new test file in the relevant `tests/` directory or choose an existing one.
  - Write your test function using the `test_` prefix.
  - Directly use the function or object you wish to test within your test function.
  - Example in `test_utils.py`:
    ```python
    from code.utils import example_function
    
    def test_example_function():
        assert example_function() == expected_result
    ```

### Creating a Fixture and Writing a Test

- **Creating a Fixture**:
  - Define a fixture function in `conftest.py` or within your test file.
  - Use the `@pytest.fixture` decorator.
  - Example in `conftest.py`:
    ```python
    import pytest
    from code.utils import SomeSharedResource
    
    @pytest.fixture
    def shared_resource():
        resource = SomeSharedResource()
        return resource
    ```

- **Creating a Test Using a Fixture**:
  - Use the fixture by specifying it as an argument to your test function.
  - Example in `test_utils.py`:
    ```python
    def test_with_shared_resource(shared_resource):
        assert shared_resource.is_valid()
    ```

## Logging

